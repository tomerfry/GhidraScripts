#!/usr/bin/env python3
"""
Ghidra-Joern Integration Script

Exports decompiled code from Ghidra, creates a Joern CPG, and opens 
a native terminal with Joern pre-configured.

Requirements:
    - Joern installed (JOERN_HOME env var or joern in PATH)

Usage:
    From Ghidra Script Manager: Run this script with a binary loaded
"""

import os
import subprocess
import tempfile
import shutil
from pathlib import Path
from dataclasses import dataclass

# Ghidra imports
try:
    from ghidra.app.decompiler import DecompInterface
    from ghidra.util.task import ConsoleTaskMonitor
    GHIDRA_AVAILABLE = True
except ImportError:
    GHIDRA_AVAILABLE = False


@dataclass
class DecompilationResult:
    name: str
    address: str
    code: str


class GhidraExporter:
    """Export decompiled code from Ghidra."""
    
    def __init__(self, program):
        self.program = program
        self.decomp = DecompInterface()
        self.decomp.openProgram(program)
        self.monitor = ConsoleTaskMonitor()
    
    def decompile_function(self, func, timeout=60):
        results = self.decomp.decompileFunction(func, timeout, self.monitor)
        if not results or not results.decompileCompleted():
            return None
        
        decomp_func = results.getDecompiledFunction()
        if not decomp_func:
            return None
        
        return DecompilationResult(
            name=func.getName(),
            address=str(func.getEntryPoint()),
            code=decomp_func.getC()
        )
    
    def export_to_directory(self, output_dir):
        """Export all decompiled code to a directory."""
        output_dir = Path(output_dir)
        output_dir.mkdir(parents=True, exist_ok=True)
        
        consolidated = output_dir / "decompiled.c"
        func_manager = self.program.getFunctionManager()
        exported = 0
        
        with open(consolidated, 'w') as f:
            f.write("// Auto-generated by Ghidra-Joern integration\n")
            f.write("#include <stdint.h>\n#include <stddef.h>\n#include <stdbool.h>\n\n")
            f.write("typedef uint8_t undefined;\n")
            f.write("typedef uint8_t undefined1;\n")
            f.write("typedef uint16_t undefined2;\n")
            f.write("typedef uint32_t undefined4;\n")
            f.write("typedef uint64_t undefined8;\n")
            f.write("typedef uint8_t byte;\n")
            f.write("typedef uint16_t word;\n")
            f.write("typedef uint32_t dword;\n")
            f.write("typedef uint64_t qword;\n\n")
            
            for func in func_manager.getFunctions(True):
                if self.monitor.isCancelled():
                    break
                if func.isExternal() or func.isThunk():
                    continue
                
                result = self.decompile_function(func)
                if result:
                    f.write("\n// === {} @ {} ===\n".format(result.name, result.address))
                    f.write(result.code)
                    f.write("\n")
                    exported += 1
                    
                    if exported % 50 == 0:
                        print("[*] Exported {} functions...".format(exported))
        
        print("[+] Exported {} functions to {}".format(exported, consolidated))
        return consolidated
    
    def close(self):
        self.decomp.dispose()


class JoernInterface:
    """Interface to Joern."""
    
    COMMON_PATHS = [
        r"C:\joern", r"C:\Program Files\joern", r"C:\tools\joern",
        os.path.expanduser(r"~\joern"), os.path.expanduser(r"~\tools\joern"),
        "/opt/joern", "/usr/local/joern", os.path.expanduser("~/joern"),
    ]
    
    def __init__(self, joern_home=None):
        self.joern_home = joern_home or os.environ.get('JOERN_HOME')
        self.joern_bin = None
        self.joern_parse = None
        self.cpg_path = None
        
        if not self._find_joern():
            self._prompt_for_path()
        
        if not self.joern_bin:
            raise RuntimeError("Joern not found. Set JOERN_HOME or add joern to PATH")
    
    def _find_joern(self):
        if self.joern_home:
            self.joern_bin = self._find_binary('joern', self.joern_home)
            self.joern_parse = self._find_binary('joern-parse', self.joern_home)
            if self.joern_bin:
                return True
        
        self.joern_bin = self._find_binary('joern')
        if self.joern_bin:
            self.joern_parse = self._find_binary('joern-parse')
            return True
        
        for path in self.COMMON_PATHS:
            if os.path.isdir(path):
                self.joern_bin = self._find_binary('joern', path)
                if self.joern_bin:
                    self.joern_home = path
                    self.joern_parse = self._find_binary('joern-parse', path)
                    print("[+] Found Joern at: {}".format(path))
                    return True
        return False
    
    def _prompt_for_path(self):
        print("\n[!] Joern not found automatically.")
        print("    Enter path to Joern installation (e.g., C:\\joern)")
        print("    Or press Enter to abort.\n")
        try:
            path = input("Joern path: ").strip().strip('"').strip("'")
            if path and os.path.isdir(path):
                self.joern_home = path
                self.joern_bin = self._find_binary('joern', path)
                self.joern_parse = self._find_binary('joern-parse', path)
        except EOFError:
            pass
    
    def _find_binary(self, name, search_dir=None):
        is_windows = os.name == 'nt'
        extensions = ['.bat', '.cmd', '.exe', ''] if is_windows else ['']
        
        if search_dir is None:
            for ext in extensions:
                result = shutil.which(name + ext)
                if result:
                    return result
            return None
        
        search_dir = Path(search_dir)
        subdirs = ['bin', 'joern-cli', 'joern-cli/bin', '']
        
        for subdir in subdirs:
            base = search_dir / subdir if subdir else search_dir
            for ext in extensions:
                candidate = base / (name + ext)
                if candidate.exists():
                    return str(candidate)
        return None
    
    def create_cpg(self, source_path, output_path=None):
        source_path = Path(source_path)
        if output_path is None:
            output_path = source_path.parent / "cpg.bin"
        
        print("[*] Generating CPG from {}...".format(source_path))
        is_windows = os.name == 'nt'
        
        if self.joern_parse:
            cmd = [self.joern_parse, str(source_path), '-o', str(output_path), '--language', 'c']
            use_shell = is_windows and self.joern_parse.endswith(('.bat', '.cmd'))
            result = subprocess.run(cmd, capture_output=True, text=True, shell=use_shell)
            if result.returncode != 0:
                print("[!] Warning: {}".format(result.stderr))
        else:
            script = 'importCode("{}")\nsave\nexit'.format(source_path.as_posix())
            subprocess.run([self.joern_bin], input=script, text=True, capture_output=True,
                          shell=is_windows and self.joern_bin.endswith(('.bat', '.cmd')))
            default_cpg = Path.home() / '.shiftleft' / 'joern' / 'workspace' / source_path.name / 'cpg.bin'
            if default_cpg.exists():
                shutil.copy(default_cpg, output_path)
        
        self.cpg_path = output_path
        print("[+] CPG saved to {}".format(output_path))
        return output_path


def launch_joern_terminal(joern_bin, cpg_path, program_name):
    """Launch Joern in a native terminal."""
    cpg_posix = str(cpg_path).replace('\\', '/')
    is_windows = os.name == 'nt'
    
    # Print import command for user
    print("")
    print("=" * 60)
    print("Run this in Joern to load the CPG:")
    print('  importCpg("{}")'.format(cpg_posix))
    print("=" * 60)
    print("")
    
    if is_windows:
        if shutil.which('wt'):
            cmd = 'wt --title "Joern - {}" cmd /k "{}"'.format(program_name, joern_bin)
        else:
            cmd = 'start "Joern - {}" cmd /k "{}"'.format(program_name, joern_bin)
        subprocess.Popen(cmd, shell=True)
    else:
        terminals = [
            ['gnome-terminal', '--', joern_bin],
            ['xterm', '-e', joern_bin],
            ['konsole', '-e', joern_bin],
        ]
        for term_cmd in terminals:
            if shutil.which(term_cmd[0]):
                subprocess.Popen(term_cmd)
                break
    
    print("[+] Joern terminal launched")


def main():
    if not GHIDRA_AVAILABLE:
        print("[!] Run this script from Ghidra Script Manager")
        return 1
    
    try:
        current_program = getCurrentProgram()  # noqa: F821
        if current_program is None:
            print("[!] No program loaded in Ghidra")
            return 1
        
        program_name = current_program.getName()
        print("[+] Program: {}".format(program_name))
        print("[+] Arch: {}".format(current_program.getLanguage().getProcessor()))
        
        workspace = Path(tempfile.mkdtemp(prefix='ghidra_joern_'))
        print("[+] Workspace: {}".format(workspace))
        
        # Export decompiled code
        exporter = GhidraExporter(current_program)
        exporter.export_to_directory(workspace)
        exporter.close()
        
        # Create CPG and launch terminal
        joern = JoernInterface()
        cpg_path = joern.create_cpg(workspace)
        launch_joern_terminal(joern.joern_bin, cpg_path, program_name)
        
        print("[*] Workspace: {}".format(workspace))
        return 0
        
    except Exception as e:
        print("[!] Error: {}".format(e))
        import traceback
        traceback.print_exc()
        return 1


if __name__ == '__main__':
    main()